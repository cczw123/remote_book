<h1>Chapter 06: Example Application</h1>
<h2>Declarative Coding</h2>
<p>We are going to switch our mindset. From here on out, we'll stop telling the computer how to do its job and instead write a specification of what we'd like as a result. I'm sure you'll find it much less stressful than trying to micromanage everything all the time.</p>
<p>Declarative, as opposed to imperative, means that we will write expressions, as opposed to step by step instructions.</p>
<p>Think of SQL. There is no "first do this, then do that". There is one expression that specifies what we'd like from the database. We don't decide how to do the work, it does. When the database is upgraded and the SQL engine optimized, we don't have to change our query. This is because there are many ways to interpret our specification and achieve the same result.</p>
<p>For some folks, myself included, it's hard to grasp the concept of declarative coding at first so let's point out a few examples to get a feel for it.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-0">// imperative
const makes = [];
for (let i = 0; i &lt; cars.length; i += 1) {
  makes.push(cars[i].make);
}

// declarative
const makes = cars.map(car =&gt; car.make);
</textarea><button onclick="runSandbox('sandbox-0')">Run Code</button><div class="sandbox-output" id="output-sandbox-0">Output will appear here...</div></div>
<p>The imperative loop must first instantiate the array. The interpreter must evaluate this statement before moving on. Then it directly iterates through the list of cars, manually increasing a counter and showing its bits and pieces to us in a vulgar display of explicit iteration.</p>
<p>The <code>map</code> version is one expression. It does not require any order of evaluation. There is much freedom here for how the map function iterates and how the returned array may be assembled. It specifies <em>what</em>, not <em>how</em>. Thus, it wears the shiny declarative sash.</p>
<p>In addition to being clearer and more concise, the map function may be optimized at will and our precious application code needn't change.</p>
<p>For those of you who are thinking "Yes, but it's much faster to do the imperative loop", I suggest you educate yourself on how the JIT optimizes your code. Here's a <a href="https://www.youtube.com/watch?v=g0ek4vV7nEA">terrific video that may shed some light</a></p>
<p>Here is another example.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-1">// imperative
const authenticate = (form) =&gt; {
  const user = toUser(form);
  return logIn(user);
};

// declarative
const authenticate = compose(logIn, toUser);
</textarea><button onclick="runSandbox('sandbox-1')">Run Code</button><div class="sandbox-output" id="output-sandbox-1">Output will appear here...</div></div>
<p>Though there's nothing necessarily wrong with the imperative version, there is still an encoded step-by-step evaluation baked in. The <code>compose</code> expression simply states a fact: Authentication is the composition of <code>toUser</code> and <code>logIn</code>. Again, this leaves wiggle room for support code changes and results in our application code being a high level specification.</p>
<p>In the example above, the order of evaluation is specified (<code>toUser</code> must be called before <code>logIn</code>), but there are many scenarios where the order is not important, and this is easily specified with declarative coding (more on this later). </p>
<p>Because we don't have to encode the order of evaluation, declarative coding lends itself to parallel computing. This coupled with pure functions is why FP is a good option for the parallel future - we don't really need to do anything special to achieve parallel/concurrent systems.</p>
<h2>A Flickr of Functional Programming</h2>
<p>We will now build an example application in a declarative, composable way. We'll still cheat and use side effects for now, but we'll keep them minimal and separate from our pure codebase. We are going to build a browser widget that sucks in flickr images and displays them. Let's start by scaffolding the app. Here's the html:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Flickr App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;main id="js-main" class="main"&gt;&lt;/main&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"&gt;&lt;/script&gt;
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>And here's the main.js skeleton:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-2">const CDN = s =&gt; `https://cdnjs.cloudflare.com/ajax/libs/${s}`;
const ramda = CDN('ramda/0.21.0/ramda.min');
const jquery = CDN('jquery/3.0.0-rc1/jquery.min');

requirejs.config({ paths: { ramda, jquery } });
requirejs(['jquery', 'ramda'], ($, { compose, curry, map, prop }) =&gt; {
  // app goes here
});
</textarea><button onclick="runSandbox('sandbox-2')">Run Code</button><div class="sandbox-output" id="output-sandbox-2">Output will appear here...</div></div>
<p>We're pulling in <a href="https://ramdajs.com">ramda</a> instead of lodash or some other utility library. It includes <code>compose</code>, <code>curry</code>, and more. I've used requirejs, which may seem like overkill, but we'll be using it throughout the book and consistency is key.</p>
<p>Now that that's out of the way, on to the spec. Our app will do 4 things.</p>
<ol>
<li>Construct a url for our particular search term</li>
<li>Make the flickr api call</li>
<li>Transform the resulting json into html images</li>
<li>Place them on the screen</li>
</ol>
<p>There are 2 impure actions mentioned above. Do you see them? Those bits about getting data from the flickr api and placing it on the screen. Let's define those first so we can quarantine them. Also, I'll add our nice <code>trace</code> function for easy debugging.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-3">const Impure = {
  getJSON: curry((callback, url) =&gt; $.getJSON(url, callback)),
  setHtml: curry((sel, html) =&gt; $(sel).html(html)),
  trace: curry((tag, x) =&gt; { console.log(tag, x); return x; }),
};
</textarea><button onclick="runSandbox('sandbox-3')">Run Code</button><div class="sandbox-output" id="output-sandbox-3">Output will appear here...</div></div>
<p>Here we've simply wrapped jQuery's methods to be curried and we've swapped the arguments to a more favorable position. I've namespaced them with <code>Impure</code> so we know these are dangerous functions. In a future example, we will make these two functions pure.</p>
<p>Next we must construct a url to pass to our <code>Impure.getJSON</code> function.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-4">const host = 'api.flickr.com';
const path = '/services/feeds/photos_public.gne';
const query = t =&gt; `?tags=${t}&amp;format=json&amp;jsoncallback=?`;
const url = t =&gt; `https://${host}${path}${query(t)}`;
</textarea><button onclick="runSandbox('sandbox-4')">Run Code</button><div class="sandbox-output" id="output-sandbox-4">Output will appear here...</div></div>
<p>There are fancy and overly complex ways of writing <code>url</code> pointfree using monoids(we'll learn about these later) or combinators. We've chosen to stick with a readable version and assemble this string in the normal pointful fashion.</p>
<p>Let's write an app function that makes the call and places the contents on the screen.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-5">const app = compose(Impure.getJSON(Impure.trace('response')), url);
app('cats');
</textarea><button onclick="runSandbox('sandbox-5')">Run Code</button><div class="sandbox-output" id="output-sandbox-5">Output will appear here...</div></div>
<p>This calls our <code>url</code> function, then passes the string to our <code>getJSON</code> function, which has been partially applied with <code>trace</code>. Loading the app will show the response from the api call in the console.</p>
<p><img alt="console response" src="images/console_ss.png"/></p>
<p>We'd like to construct images out of this json. It looks like the <code>mediaUrls</code> are buried in <code>items</code> then each <code>media</code>'s <code>m</code> property.</p>
<p>Anyhow, to get at these nested properties we can use a nice universal getter function from ramda called <code>prop</code>. Here's a homegrown version so you can see what's happening:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-6">const prop = curry((property, object) =&gt; object[property]);
</textarea><button onclick="runSandbox('sandbox-6')">Run Code</button><div class="sandbox-output" id="output-sandbox-6">Output will appear here...</div></div>
<p>It's quite dull actually. We just use <code>[]</code> syntax to access a property on whatever object. Let's use this to get at our <code>mediaUrls</code>.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-7">const mediaUrl = compose(prop('m'), prop('media'));
const mediaUrls = compose(map(mediaUrl), prop('items'));
</textarea><button onclick="runSandbox('sandbox-7')">Run Code</button><div class="sandbox-output" id="output-sandbox-7">Output will appear here...</div></div>
<p>Once we gather the <code>items</code>, we must <code>map</code> over them to extract each media url. This results in a nice array of <code>mediaUrls</code>. Let's hook this up to our app and print them on the screen.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-8">const render = compose(Impure.setHtml('#js-main'), mediaUrls);
const app = compose(Impure.getJSON(render), url);
</textarea><button onclick="runSandbox('sandbox-8')">Run Code</button><div class="sandbox-output" id="output-sandbox-8">Output will appear here...</div></div>
<p>All we've done is make a new composition that will call our <code>mediaUrls</code> and set the <code>&lt;main&gt;</code> html with them. We've replaced the <code>trace</code> call with <code>render</code> now that we have something to render besides raw json. This will crudely display our <code>mediaUrls</code> within the body.</p>
<p>Our final step is to turn these <code>mediaUrls</code> into bonafide <code>images</code>. In a bigger application, we'd use a template/dom library like Handlebars or React. For this application though, we only need an img tag so let's stick with jQuery.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-9">const img = src =&gt; $('&lt;img /&gt;', { src });
</textarea><button onclick="runSandbox('sandbox-9')">Run Code</button><div class="sandbox-output" id="output-sandbox-9">Output will appear here...</div></div>
<p>jQuery's <code>html</code> method will accept an array of tags. We only have to transform our mediaUrls into images and send them along to <code>setHtml</code>.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-10">const images = compose(map(img), mediaUrls);
const render = compose(Impure.setHtml('#js-main'), images);
const app = compose(Impure.getJSON(render), url);
</textarea><button onclick="runSandbox('sandbox-10')">Run Code</button><div class="sandbox-output" id="output-sandbox-10">Output will appear here...</div></div>
<p>And we're done!</p>
<p><img alt="cats grid" src="images/cats_ss.png"/></p>
<p>Here is the finished script:
<a href="./exercises/ch06/main.js">include</a></p>
<p>Now look at that. A beautifully declarative specification of what things are, not how they come to be. We now view each line as an equation with properties that hold. We can use these properties to reason about our application and refactor.</p>
<h2>A Principled Refactor</h2>
<p>There is an optimization available - we map over each item to turn it into a media url, then we map again over those mediaUrls to turn them into img tags. There is a law regarding map and composition:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-11">// map's composition law
compose(map(f), map(g)) === map(compose(f, g));
</textarea><button onclick="runSandbox('sandbox-11')">Run Code</button><div class="sandbox-output" id="output-sandbox-11">Output will appear here...</div></div>
<p>We can use this property to optimize our code. Let's have a principled refactor.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-12">// original code
const mediaUrl = compose(prop('m'), prop('media'));
const mediaUrls = compose(map(mediaUrl), prop('items'));
const images = compose(map(img), mediaUrls);
</textarea><button onclick="runSandbox('sandbox-12')">Run Code</button><div class="sandbox-output" id="output-sandbox-12">Output will appear here...</div></div>
<p>Let's line up our maps. We can inline the call to <code>mediaUrls</code> in <code>images</code> thanks to equational reasoning and purity.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-13">const mediaUrl = compose(prop('m'), prop('media'));
const images = compose(map(img), map(mediaUrl), prop('items'));
</textarea><button onclick="runSandbox('sandbox-13')">Run Code</button><div class="sandbox-output" id="output-sandbox-13">Output will appear here...</div></div>
<p>Now that we've lined up our <code>map</code>s we can apply the composition law.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-14">/*
compose(map(f), map(g)) === map(compose(f, g));
compose(map(img), map(mediaUrl)) === map(compose(img, mediaUrl));
*/

const mediaUrl = compose(prop('m'), prop('media'));
const images = compose(map(compose(img, mediaUrl)), prop('items'));
</textarea><button onclick="runSandbox('sandbox-14')">Run Code</button><div class="sandbox-output" id="output-sandbox-14">Output will appear here...</div></div>
<p>Now the bugger will only loop once while turning each item into an img. Let's just make it a little more readable by extracting the function out.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-15">const mediaUrl = compose(prop('m'), prop('media'));
const mediaToImg = compose(img, mediaUrl);
const images = compose(map(mediaToImg), prop('items'));
</textarea><button onclick="runSandbox('sandbox-15')">Run Code</button><div class="sandbox-output" id="output-sandbox-15">Output will appear here...</div></div>
<h2>In Summary</h2>
<p>We have seen how to put our new skills into use with a small, but real world app. We've used our mathematical framework to reason about and refactor our code. But what about error handling and code branching? How can we make the whole application pure instead of merely namespacing destructive functions? How can we make our app safer and more expressive? These are the questions we will tackle in part 2.</p>
<p><a href="ch07.html">Chapter 07: Hindley-Milner and Me</a></p>
<script>
function runSandbox(id) {
    const code = document.getElementById('code-' + id).value;
    const output = document.getElementById('output-' + id);
    output.innerHTML = '';
    
    const originalLog = console.log;
    console.log = function(...args) {
        args.forEach(arg => {
            output.innerHTML += '<div>' + arg + '</div>';
        });
        originalLog.apply(console, args);
    };

    try {
        eval(code);
    } catch (e) {
        output.innerHTML += '<div style="color: red;">Error: ' + e.message + '</div>';
    } finally {
        console.log = originalLog;
    }
}
</script>
<style>
.sandbox { border: 1px solid #ccc; padding: 10px; margin: 10px 0; border-radius: 5px; background-color: #f9f9f9; }
.sandbox textarea { width: 100%; height: 100px; font-family: monospace; margin-bottom: 5px; padding: 5px; box-sizing: border-box; }
.sandbox button { padding: 5px 10px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 3px; }
.sandbox button:hover { background-color: #0056b3; }
.sandbox-output { background: #fff; padding: 10px; margin-top: 5px; border: 1px solid #ddd; min-height: 40px; font-family: monospace; }
</style>
