<h1>Chapter 13: Monoids bring it all together</h1>
<h2>Wild combination</h2>
<p>In this chapter, we will examine <em>monoids</em> by way of <em>semigroup</em>. <em>Monoids</em> are the bubblegum in the hair of mathematical abstraction. They capture an idea that spans multiple disciplines, figuratively and literally bringing them all together. They are the ominous force that connects all that calculates. The oxygen in our code base, the ground on which it runs, quantum entanglement encoded.</p>
<p><em>Monoids</em> are about combination. But what is combination? It can mean so many things from accumulation to concatenation to multiplication to choice, composition, ordering, even evaluation! We'll see many examples here, but we'll only tip-toe on the foothills of monoid mountain. The instances are plentiful and applications vast. The aim of this chapter is to provide a good intuition so you can make some <em>monoids</em> of your own.</p>
<h2>Abstracting addition</h2>
<p>Addition has some interesting qualities I'd like to discuss. Let's have a look at it through our abstraction goggles.</p>
<p>For starters, it's a binary operation, that is, an operation which takes two values and returns a value, all within the same set.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-0">// a binary operation
1 + 1 = 2
</textarea><button onclick="runSandbox('sandbox-0')">Run Code</button><div class="sandbox-output" id="output-sandbox-0">Output will appear here...</div></div>
<p>See? Two values in the domain, one value in the codomain, all the same set - numbers, as it were. Some might say numbers are "closed under addition", meaning the type won't ever change no matter which ones get tossed into the mix. That means we can chain the operation since the result is always another number:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-1">// we can run this on any amount of numbers
1 + 7 + 5 + 4 + ...
</textarea><button onclick="runSandbox('sandbox-1')">Run Code</button><div class="sandbox-output" id="output-sandbox-1">Output will appear here...</div></div>
<p>In addition to that (what a calculated pun...), we have associativity which buys us the ability to group operations however we please. Incidentally, an associative, binary operation is a recipe for parallel computation because we can chunk and distribute work.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-2">// associativity
(1 + 2) + 3 = 6
1 + (2 + 3) = 6
</textarea><button onclick="runSandbox('sandbox-2')">Run Code</button><div class="sandbox-output" id="output-sandbox-2">Output will appear here...</div></div>
<p>Now, don't go confusing this with commutativity which allows us to rearrange the order. While that holds for addition, we're not particularly interested in that property at the moment - too specific for our abstraction needs.</p>
<p>Come to think of it, what properties should be in our abstract superclass anyways? What traits are specific to addition and what ones can be generalized? Are there other abstractions amidst this hierarchy or is it all one chunk? It's this kind of thinking that our mathematical forefathers applied when conceiving the interfaces in abstract algebra.</p>
<p>As it happens, those old school abstractionists landed on the concept of a <em>group</em> when abstracting addition. A <em>group</em> has all the bells and whistles including the concept of negative numbers. Here, we're only interested in that associative binary operator so we'll choose the less specific interface <em>Semigroup</em>. A <em>Semigroup</em> is a type with a <code>concat</code> method which acts as our associative binary operator.</p>
<p>Let's implement it for addition and call it <code>Sum</code>:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-3">const Sum = x =&gt; ({
  x,
  concat: other =&gt; Sum(x + other.x)
})
</textarea><button onclick="runSandbox('sandbox-3')">Run Code</button><div class="sandbox-output" id="output-sandbox-3">Output will appear here...</div></div>
<p>Note we <code>concat</code> with some other <code>Sum</code> and always return a <code>Sum</code>.</p>
<p>I've used an object factory here instead of our typical prototype ceremony, primarily because <code>Sum</code> is not <em>pointed</em> and we don't want to have to type <code>new</code>. Anyways, here it is in action:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-4">Sum(1).concat(Sum(3)) // Sum(4)
Sum(4).concat(Sum(37)) // Sum(41)
</textarea><button onclick="runSandbox('sandbox-4')">Run Code</button><div class="sandbox-output" id="output-sandbox-4">Output will appear here...</div></div>
<p>Just like that, we can program to an interface, not an implementation. Since this interface comes from group theory it has centuries of literature backing it up. Free docs!</p>
<p>Now, as mentioned, <code>Sum</code> is not <em>pointed</em>, nor a <em>functor</em>. As an exercise, go back and check the laws to see why. Okay, I'll just tell you: it can only hold a number, so <code>map</code> does not make sense here as we cannot transform the underlying value to another type. That would be a very limited <code>map</code> indeed!</p>
<p>So why is this useful? Well, as with any interface, we can swap out our instance to achieve different results:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-5">const Product = x =&gt; ({ x, concat: other =&gt; Product(x * other.x) })

const Min = x =&gt; ({ x, concat: other =&gt; Min(x &lt; other.x ? x : other.x) })

const Max = x =&gt; ({ x, concat: other =&gt; Max(x &gt; other.x ? x : other.x) })
</textarea><button onclick="runSandbox('sandbox-5')">Run Code</button><div class="sandbox-output" id="output-sandbox-5">Output will appear here...</div></div>
<p>This isn't limited to numbers, though. Let's see some other types:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-6">const Any = x =&gt; ({ x, concat: other =&gt; Any(x || other.x) })
const All = x =&gt; ({ x, concat: other =&gt; All(x &amp;&amp; other.x) })

Any(false).concat(Any(true)) // Any(true)
Any(false).concat(Any(false)) // Any(false)

All(false).concat(All(true)) // All(false)
All(true).concat(All(true)) // All(true)

[1,2].concat([3,4]) // [1,2,3,4]

"miracle grow".concat("n") // miracle grown"

Map({day: 'night'}).concat(Map({white: 'nikes'})) // Map({day: 'night', white: 'nikes'})
</textarea><button onclick="runSandbox('sandbox-6')">Run Code</button><div class="sandbox-output" id="output-sandbox-6">Output will appear here...</div></div>
<p>If you stare at these long enough the pattern will pop out at you like a magic eye poster. It's everywhere. We're merging data structures, combining logic, building strings...it seems one can bludgeon almost any task into this combination based interface.</p>
<p>I've used <code>Map</code> a few times now. Pardon me if you two weren't properly introduced. <code>Map</code> simply wraps <code>Object</code> so we can embellish it with some extra methods without altering the fabric of the universe.</p>
<h2>All my favourite functors are semigroups.</h2>
<p>The types we've seen so far which implement the functor interface all implement semigroup one as well. Let's look at <code>Identity</code> (the artist previously known as Container):</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-7">Identity.prototype.concat = function(other) {
  return new Identity(this.__value.concat(other.__value))
}

Identity.of(Sum(4)).concat(Identity.of(Sum(1))) // Identity(Sum(5))
Identity.of(4).concat(Identity.of(1)) // TypeError: this.__value.concat is not a function
</textarea><button onclick="runSandbox('sandbox-7')">Run Code</button><div class="sandbox-output" id="output-sandbox-7">Output will appear here...</div></div>
<p>It is a <em>semigroup</em> if and only if its <code>__value</code> is a <em>semigroup</em>. Like a butterfingered hang glider, it is one whilst it holds one.</p>
<p>Other types have similar behavior:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-8">// combine with error handling
Right(Sum(2)).concat(Right(Sum(3))) // Right(Sum(5))
Right(Sum(2)).concat(Left('some error')) // Left('some error')


// combine async
Task.of([1,2]).concat(Task.of([3,4])) // Task([1,2,3,4])
</textarea><button onclick="runSandbox('sandbox-8')">Run Code</button><div class="sandbox-output" id="output-sandbox-8">Output will appear here...</div></div>
<p>This gets particularly useful when we stack these semigroups into a cascading combination:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-9">// formValues :: Selector -&gt; IO (Map String String)
// validate :: Map String String -&gt; Either Error (Map String String)

formValues('#signup').map(validate).concat(formValues('#terms').map(validate)) // IO(Right(Map({username: 'andre3000', accepted: true})))
formValues('#signup').map(validate).concat(formValues('#terms').map(validate)) // IO(Left('one must accept our totalitarian agreement'))

serverA.get('/friends').concat(serverB.get('/friends')) // Task([friend1, friend2])

// loadSetting :: String -&gt; Task Error (Maybe (Map String Boolean))
loadSetting('email').concat(loadSetting('general')) // Task(Maybe(Map({backgroundColor: true, autoSave: false})))
</textarea><button onclick="runSandbox('sandbox-9')">Run Code</button><div class="sandbox-output" id="output-sandbox-9">Output will appear here...</div></div>
<p>In the top example, we've combined an <code>IO</code> holding an <code>Either</code> holding a <code>Map</code> to validate and merge form values. Next, we've hit a couple of different servers and combined their results in an async way using <code>Task</code> and <code>Array</code>. Lastly, we've stacked <code>Task</code>, <code>Maybe</code>, and <code>Map</code> to load, parse, and merge multiple settings.</p>
<p>These can be <code>chain</code>ed or <code>ap</code>'d, but <em>semigroups</em> capture what we'd like to do much more concisely.</p>
<p>This extends beyond functors. In fact, it turns out that anything made up entirely of semigroups, is itself, a semigroup: if we can concat the kit, then we can concat the caboodle.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-10">const Analytics = (clicks, path, idleTime) =&gt; ({
  clicks,
  path,
  idleTime,
  concat: other =&gt;
    Analytics(clicks.concat(other.clicks), path.concat(other.path), idleTime.concat(other.idleTime))
})

Analytics(Sum(2), ['/home', '/about'], Right(Max(2000))).concat(Analytics(Sum(1), ['/contact'], Right(Max(1000))))
// Analytics(Sum(3), ['/home', '/about', '/contact'], Right(Max(2000)))
</textarea><button onclick="runSandbox('sandbox-10')">Run Code</button><div class="sandbox-output" id="output-sandbox-10">Output will appear here...</div></div>
<p>See, everything knows how to combine itself nicely. Turns out, we could do the same thing for free just by using the <code>Map</code> type:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-11">Map({clicks: Sum(2), path: ['/home', '/about'], idleTime: Right(Max(2000))}).concat(Map({clicks: Sum(1), path: ['/contact'], idleTime: Right(Max(1000))}))
// Map({clicks: Sum(3), path: ['/home', '/about', '/contact'], idleTime: Right(Max(2000))})
</textarea><button onclick="runSandbox('sandbox-11')">Run Code</button><div class="sandbox-output" id="output-sandbox-11">Output will appear here...</div></div>
<p>We can stack and combine as many of these as we'd like. It's simply a matter of adding another tree to the forest, or another flame to the forest fire depending on your codebase.</p>
<p>The default, intuitive behavior is to combine what a type is holding, however, there are cases where we ignore what's inside and combine the containers themselves. Consider a type like <code>Stream</code>:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-12">const submitStream = Stream.fromEvent('click', $('#submit'))
const enterStream = filter(x =&gt; x.key === 'Enter', Stream.fromEvent('keydown', $('#myForm')))

submitStream.concat(enterStream).map(submitForm) // Stream()
</textarea><button onclick="runSandbox('sandbox-12')">Run Code</button><div class="sandbox-output" id="output-sandbox-12">Output will appear here...</div></div>
<p>We can combine event streams by capturing events from both as one new stream. Alternatively, we could have combined them by insisting they hold a semigroup. In fact, there are many possible instances for each type. Consider <code>Task</code>, we can combine them by choosing the earlier or later of the two. We can always chose the first <code>Right</code> instead of short circuiting on <code>Left</code> which has the effect of ignoring errors. There is an interface called <em>Alternative</em> which implements some of these, well, alternative instances, typically focused on choice rather than cascading combination. It is worth looking into if you are in need of such functionality.</p>
<h2>Monoids for nothing</h2>
<p>We were abstracting addition, but like the Babylonians, we lacked the concept of zero (there were zero mentions of it).</p>
<p>Zero acts as <em>identity</em> meaning any element added to <code>0</code>, will return back that very same element. Abstraction-wise, it's helpful to think of <code>0</code> as a kind of neutral or <em>empty</em> element. It's important that it act the same way on the left and right side of our binary operation:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-13">// identity
1 + 0 = 1
0 + 1 = 1
</textarea><button onclick="runSandbox('sandbox-13')">Run Code</button><div class="sandbox-output" id="output-sandbox-13">Output will appear here...</div></div>
<p>Let's call this concept <code>empty</code> and create a new interface with it. Like so many startups, we'll choose a heinously uninformative, yet conveniently googleable name: <em>Monoid</em>. The recipe for <em>Monoid</em> is to take any <em>semigroup</em> and add a special <em>identity</em> element. We'll implement that with an <code>empty</code> function on the type itself:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-14">Array.empty = () =&gt; []
String.empty = () =&gt; ""
Sum.empty = () =&gt; Sum(0)
Product.empty = () =&gt; Product(1)
Min.empty = () =&gt; Min(Infinity)
Max.empty = () =&gt; Max(-Infinity)
All.empty = () =&gt; All(true)
Any.empty = () =&gt; Any(false)
</textarea><button onclick="runSandbox('sandbox-14')">Run Code</button><div class="sandbox-output" id="output-sandbox-14">Output will appear here...</div></div>
<p>When might an empty, identity value prove useful? That's like asking why zero is useful. Like not asking anything at all...</p>
<p>When we have nothing else, who can we count on? Zero. How many bugs do we want? Zero. It's our tolerance for unsafe code. A fresh start. The ultimate price tag. It can annihilate everything in its path or save us in a pinch. A golden life saver and a pit of despair.</p>
<p>Codewise, they correspond to sensible defaults:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-15">const settings = (prefix="", overrides=[], total=0) =&gt; ...

const settings = (prefix=String.empty(), overrides=Array.empty(), total=Sum.empty()) =&gt; ...
</textarea><button onclick="runSandbox('sandbox-15')">Run Code</button><div class="sandbox-output" id="output-sandbox-15">Output will appear here...</div></div>
<p>Or to return a useful value when we have nothing else:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-16">sum([]) // 0
</textarea><button onclick="runSandbox('sandbox-16')">Run Code</button><div class="sandbox-output" id="output-sandbox-16">Output will appear here...</div></div>
<p>They are also the perfect initial value for an accumulator...</p>
<h2>Folding down the house</h2>
<p>It just so happens that <code>concat</code> and <code>empty</code> fit perfectly in the first two slots of <code>reduce</code>. We can actually <code>reduce</code> an array of <em>semigroup</em>'s down by ignoring the <em>empty</em> value, but as you can see, that leads to a precarious situation:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-17">// concat :: Semigroup s =&gt; s -&gt; s -&gt; s
const concat = x =&gt; y =&gt; x.concat(y)

[Sum(1), Sum(2)].reduce(concat) // Sum(3)

[].reduce(concat) // TypeError: Reduce of empty array with no initial value
</textarea><button onclick="runSandbox('sandbox-17')">Run Code</button><div class="sandbox-output" id="output-sandbox-17">Output will appear here...</div></div>
<p>Boom goes the dynamite. Like a twisted ankle in a marathon, we have ourselves a runtime exception. JavaScript is more than happy to let us strap pistols to our sneakers before running - it is a conservative sort of language, I suppose, but it stops us dead in our tracks when the array is barren. What could it return anyhow? <code>NaN</code>, <code>false</code>, <code>-1</code>? If we were to continue on in our program, we'd like a result of the right type. It could return a <code>Maybe</code> to indicate the possibility of failure, but we can do one better.</p>
<p>Let's use our curried <code>reduce</code> function and make a safe version where the <code>empty</code> value is not optional. It shall henceforth be known as <code>fold</code>:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-18">// fold :: Monoid m =&gt; m -&gt; [m] -&gt; m
const fold = reduce(concat)
</textarea><button onclick="runSandbox('sandbox-18')">Run Code</button><div class="sandbox-output" id="output-sandbox-18">Output will appear here...</div></div>
<p>The initial <code>m</code> is our <code>empty</code> value - our neutral, starting point, then we take an array of <code>m</code>'s and crush them down to one beautiful diamond like value.</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-19">fold(Sum.empty(), [Sum(1), Sum(2)]) // Sum(3)
fold(Sum.empty(), []) // Sum(0)

fold(Any.empty(), [Any(false), Any(true)]) // Any(true)
fold(Any.empty(), []) // Any(false)


fold(Either.of(Max.empty()), [Right(Max(3)), Right(Max(21)), Right(Max(11))]) // Right(Max(21))
fold(Either.of(Max.empty()), [Right(Max(3)), Left('error retrieving value'), Right(Max(11))]) // Left('error retrieving value')

fold(IO.of([]), ['.link', 'a'].map($)) // IO([&lt;a&gt;, &lt;button class="link"/&gt;, &lt;a&gt;])
</textarea><button onclick="runSandbox('sandbox-19')">Run Code</button><div class="sandbox-output" id="output-sandbox-19">Output will appear here...</div></div>
<p>We've provided a manual <code>empty</code> value for those last two since we can't define one on the type itself. That's totally fine. Typed languages can figure that out by themselves, but we have to pass it in here.</p>
<h2>Not quite a monoid</h2>
<p>There are some <em>semigroups</em> that cannot become <em>monoids</em>, that is provide an initial value. Look at <code>First</code>:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-20">const First = x =&gt; ({ x, concat: other =&gt; First(x) })

Map({id: First(123), isPaid: Any(true), points: Sum(13)}).concat(Map({id: First(2242), isPaid: Any(false), points: Sum(1)}))
// Map({id: First(123), isPaid: Any(true), points: Sum(14)})
</textarea><button onclick="runSandbox('sandbox-20')">Run Code</button><div class="sandbox-output" id="output-sandbox-20">Output will appear here...</div></div>
<p>We'll merge a couple of accounts and keep the <code>First</code> id. There is no way to define an <code>empty</code> value for it. Doesn't mean it's not useful.</p>
<h2>Grand unifying theory</h2>
<h2>Group theory or Category theory?</h2>
<p>The notion of a binary operation is everywhere in abstract algebra. It is, in fact, the primary operation for a <em>category</em>. We cannot, however, model our operation in category theory without an <em>identity</em>. This is the reason we start with a semi-group from group theory, then jump to a monoid in category theory once we have <em>empty</em>.</p>
<p>Monoids form a single object category where the morphism is <code>concat</code>, <code>empty</code> is the identity, and composition is guaranteed.</p>
<h3>Composition as a monoid</h3>
<p>Functions of type <code>a -&gt; a</code>, where the domain is in the same set as the codomain, are called <em>endomorphisms</em>. We can make a <em>monoid</em> called <code>Endo</code> which captures this idea:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-21">const Endo = run =&gt; ({
  run,
  concat: other =&gt;
    Endo(compose(run, other.run))
})

Endo.empty = () =&gt; Endo(identity)


// in action

// thingDownFlipAndReverse :: Endo [String] -&gt; [String]
const thingDownFlipAndReverse = fold(Endo(() =&gt; []), [Endo(reverse), Endo(sort), Endo(append('thing down')])

thingDownFlipAndReverse.run(['let me work it', 'is it worth it?'])
// ['thing down', 'let me work it', 'is it worth it?']
</textarea><button onclick="runSandbox('sandbox-21')">Run Code</button><div class="sandbox-output" id="output-sandbox-21">Output will appear here...</div></div>
<p>Since they are all the same type, we can <code>concat</code> via <code>compose</code> and the types always line up.</p>
<h3>Monad as a monoid</h3>
<p>You may have noticed that <code>join</code> is an operation which takes two (nested) monads and squashes them down to one in an associative fashion. It is also a natural transformation or "functor function". As previously stated, we can make a category of functors as objects with natural transformations as morphisms. Now, if we specialize it to <em>Endofunctors</em>, that is functors of the same type, then <code>join</code> provides us with a monoid in the category of Endofunctors also known as a Monad. To show the exact formulation in code takes a little finagling which I encourage you to google, but that's the general idea.</p>
<h3>Applicative as a monoid</h3>
<p>Even applicative functors have a monoidal formulation known in the category theory as a <em>lax monoidal functor</em>. We can implement the interface as a monoid and recover <code>ap</code> from it:</p>
<div class="sandbox"><p style="margin-top: 0; font-weight: bold;">JavaScript Sandbox (Editable):</p><textarea id="code-sandbox-22">// concat :: f a -&gt; f b -&gt; f [a, b]
// empty :: () -&gt; f ()

// ap :: Functor f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
const ap = compose(map(([f, x]) =&gt; f(x)), concat)
</textarea><button onclick="runSandbox('sandbox-22')">Run Code</button><div class="sandbox-output" id="output-sandbox-22">Output will appear here...</div></div>
<h2>In summary</h2>
<p>So you see, everything is connected, or can be. This profound realization makes <em>Monoids</em> a powerful modelling tool for broad swaths of app architecture to the tiniest pieces of datum. I encourage you to think of <em>monoids</em> whenever direct accumulation or combination is part of your application, then once you've got that down, start to stretch the definition to more applications (you'd be surprised how much one can model with a <em>monoid</em>).</p>
<h2>Exercises</h2>
<script>
function runSandbox(id) {
    const code = document.getElementById('code-' + id).value;
    const output = document.getElementById('output-' + id);
    output.innerHTML = '';
    
    const originalLog = console.log;
    console.log = function(...args) {
        args.forEach(arg => {
            output.innerHTML += '<div>' + arg + '</div>';
        });
        originalLog.apply(console, args);
    };

    try {
        eval(code);
    } catch (e) {
        output.innerHTML += '<div style="color: red;">Error: ' + e.message + '</div>';
    } finally {
        console.log = originalLog;
    }
}
</script>
<style>
.sandbox { border: 1px solid #ccc; padding: 10px; margin: 10px 0; border-radius: 5px; background-color: #f9f9f9; }
.sandbox textarea { width: 100%; height: 100px; font-family: monospace; margin-bottom: 5px; padding: 5px; box-sizing: border-box; }
.sandbox button { padding: 5px 10px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 3px; }
.sandbox button:hover { background-color: #0056b3; }
.sandbox-output { background: #fff; padding: 10px; margin-top: 5px; border: 1px solid #ddd; min-height: 40px; font-family: monospace; }
</style>
